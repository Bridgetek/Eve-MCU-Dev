# EVE-MCU-Dev Fontmagic Example

[Back](../README.md)

## Font Magic Example

The `fontmagic` example demonstrates loading a custom font and manipulating text output. It parses arguments and uses them to determine the display list for the BT82x.

The demo will write text on the BT82x screen using both a custom and ROM font. 

There are 3 modes of operation. The `standard`, `ascii` and `symbol` modes. 

In the standard mode, the text is written at an angle using the `cmd_textrotate` function, and scaled using the `cmd_textzoom` function. The ascii and symbol modes will characters from 32 to 127 for ascii and 0 to 95 available for symbol mode.

To make the scaling and rotation possible the program needs to know the widths of each character in the font. Therefore there is code that will read the font descriptors and calculate the widths of each character. This is stored in a python tuple called the font cache. This is initialised with the `getromfontinfo` function for ROM fonts and `getcustomfontinfo` for custom fonts.

This example supports the following platforms:

| Port Name | Port Directory | Supported |
| --- | --- | --- |
|ST STM32 (Keil) | STM32 | Yes (1) |
|ST STM32Cube | STM32CUBE | Yes (1) |
|Generic using libFT4222 | libft4222 | Yes |

(1) - EVE API 5 support in progress

Supported EVE APIs in this example:

| EVE API 1 | EVE API 2 | EVE API 3 | EVE API 4 | EVE API 5 |
| --- | --- | --- | --- | --- |
| No | No | No | No | Yes |

The following is an screenshot of the simple example.

![Font Magic Example](docs/fontmagic.png)

_Example code running in standard mode._

The demo mode (standard, ascii or symbol) is set as the first parameter in the command line, the second parameter sets the custom font to use. Other fonts can be used with this example code if the `.raw` file is generated by the EVE Asset Builder (EAB) utility.

Some fonts have their start address set in the EAB utility, this is used to load fonts into a specific location in RAM_G. This can be passed to the example code using the `-d` parameter. The default value is a start address of 0 (zero).

Legacy fonts typically start at character 0 or character 32, use the `-l` parameter to set this. The default value is 32. This is only used for legacy fonts.

### `main.c`

The application starts up in the file `main.c` which provides initial MCU configuration and then calls `eve_example.c` where the remainder of the application will be carried out. 

The `main.c` code is platform specific. It must provide any functions that rely on a platform's operating system, or built-in non-volatile storage mechanism. The required functions store and recall previous touch screen calibration settings:
- **platform_calib_init** initialise a platform's non-volatile storage system.
- **platform_calib_read** read a previous touch screen calibration or return a value indicating that there are no stored calibration setting.
- **platform_calib_write** write a touch screen calibration to the platform's non-volatile storage.

The example program in the common code is then called.

### `eve_example.c`

In the function `eve_example` the basic initialisation is performed:

```
void eve_example(void)
{
    uint32_t font_end;
    // Initialise the display
    EVE_Init();
    // Calibrate the display
    eve_calibrate();
    // Start example code
```
The call to `EVE_Init()` is made which sets up the EVE environment on the platform. This will initialise the SPI communications to the EVE device and set-up the device ready to receive communication from the host.

Next, the function `eve_calibrate()` is then called which uses the calibration co-processor command to display the calibration screen and asks the user to tap the three dots (see `touch.c` below).

Once calibration is complete, the code will load in the custom font and create a cache data structure of font information.

```
    // Load fonts and images.
    printf("Loading font...\n");
    loadlegacyfont(font0, font0_size, font0_offset);

    // Start example code.
    printf("Starting demo...\n");
    getromfontinfo(&romfontcache, FONT_ROM);
    getcustomfontinfo(&customfontcache, FONT_CUSTOM, font0_offset, font0_first);
```

The code will then draw various versions of output to the screen depending on the `action` variable. When a touch event is detected then it will move to the next action.

### `touch.c`

This function is used to show the touchscreen calibration screen and prompt the user to touch the screen at the required positions to generate an accurate transformation matrix. This matrix is used to translate the raw touch input into precise points on the screen.

The platform specific functions in `main.c` are called from this routine to store and read touchscreen calibration settings so that the user only needs to perform the action once.

### `eve_fonts.c`

This file contains the data array of a font which was produced by the Font Converter tool which is part of EVE Asset Builder. The code in this file will send the commands to the co-processor to load the font into RAM_G and set-up the font for use. The font loaded is used as the custom font `FONT_CUSTOM` in the code.

## Files and Folders

The example contains a common directory with several files which comprises all the demo functionality.

| File/Folder | Description |
| --- | --- |
| [common/eve_example.c](common/eve_example.c) | Example source code file |
| [snippets/touch.c](../snippets/touch.c) | Calibration and touch detection routines |
| [common/eve_fonts.c](common/eve_fonts.c) | Font helper routines |
| [docs](docs) | Documentation support files |
